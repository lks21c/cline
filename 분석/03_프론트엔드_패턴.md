# 프론트엔드 패턴

Cline 프로젝트의 React 기반 프론트엔드 아키텍처와 UI 패턴을 분석합니다.

---

## 1. Hook 기반 상태 관리

### 개요
복잡한 채팅 UI 상태를 작은 커스텀 훅으로 분리하여 관리합니다. 각 훅은 단일 책임을 가지며, 조합하여 전체 상태를 구성합니다.

### 디렉토리 구조

```
webview-ui/src/
├── components/chat/
│   ├── chat-view/
│   │   ├── hooks/               # 채팅 전용 훅
│   │   │   ├── useChatState.ts
│   │   │   ├── useScrollBehavior.ts
│   │   │   ├── useMessageHandlers.ts
│   │   │   └── index.ts
│   │   ├── components/layout/   # 레이아웃 컴포넌트
│   │   └── types/               # 타입 정의
│   └── ChatView.tsx             # 메인 뷰
├── context/                     # 전역 Context
│   ├── ExtensionStateContext.tsx
│   └── PlatformContext.tsx
└── hooks/                       # 공통 훅
    ├── useMenuAnnouncement.ts
    └── useFeatureFlag.ts
```

### useChatState 훅

```typescript
// webview-ui/src/components/chat/chat-view/hooks/useChatState.ts

export interface ChatState {
    // 입력 상태
    inputValue: string
    setInputValue: (v: string) => void
    selectedImages: string[]
    setSelectedImages: (v: string[]) => void
    selectedFiles: string[]
    setSelectedFiles: (v: string[]) => void

    // UI 상태
    sendingDisabled: boolean
    enableButtons: boolean
    expandedRows: Record<number, boolean>

    // 파생 값 (메모이제이션)
    lastMessage: ClineMessage | undefined
    clineAsk: string | undefined
    task: ClineMessage | undefined

    // 핸들러
    resetState: () => void
    clearExpandedRows: () => void

    // Ref
    textAreaRef: RefObject<HTMLTextAreaElement>
}

export function useChatState(messages: ClineMessage[]): ChatState {
    // 입력 상태
    const [inputValue, setInputValue] = useState("")
    const [selectedImages, setSelectedImages] = useState<string[]>([])
    const [selectedFiles, setSelectedFiles] = useState<string[]>([])

    // UI 상태
    const [sendingDisabled, setSendingDisabled] = useState(false)
    const [enableButtons, setEnableButtons] = useState<boolean>(false)
    const [expandedRows, setExpandedRows] = useState<Record<number, boolean>>({})

    // Refs
    const textAreaRef = useRef<HTMLTextAreaElement>(null)

    // 파생 상태 (useMemo로 최적화)
    const lastMessage = useMemo(() => messages.at(-1), [messages])
    const task = useMemo(() => messages.at(0), [messages])
    const clineAsk = useMemo(
        () => (lastMessage?.type === "ask" ? lastMessage.ask : undefined),
        [lastMessage]
    )

    // 리셋 핸들러
    const resetState = useCallback(() => {
        setInputValue("")
        setSelectedImages([])
        setSelectedFiles([])
    }, [])

    return {
        inputValue, setInputValue,
        selectedImages, setSelectedImages,
        selectedFiles, setSelectedFiles,
        sendingDisabled, setSendingDisabled,
        enableButtons, setEnableButtons,
        expandedRows, setExpandedRows,
        textAreaRef,
        lastMessage, task, clineAsk,
        resetState,
        clearExpandedRows: () => setExpandedRows({}),
    }
}
```

### useScrollBehavior 훅

```typescript
// webview-ui/src/components/chat/chat-view/hooks/useScrollBehavior.ts

export interface ScrollBehavior {
    virtuosoRef: RefObject<VirtuosoHandle>
    scrollContainerRef: RefObject<HTMLDivElement>
    disableAutoScrollRef: MutableRefObject<boolean>

    // 스크롤 동작
    scrollToBottomSmooth: () => void
    scrollToBottomAuto: () => void
    scrollToMessage: (messageIndex: number) => void
    toggleRowExpansion: (ts: number) => void
    handleRowHeightChange: (isTaller: boolean) => void

    // 상태
    showScrollToBottom: boolean
    isAtBottom: boolean
    scrolledPastUserMessage: ClineMessage | null
}

export function useScrollBehavior(
    messages: ClineMessage[],
    visibleMessages: ClineMessage[],
    groupedMessages: (ClineMessage | ClineMessage[])[],
    expandedRows: Record<number, boolean>,
    setExpandedRows: Dispatch<SetStateAction<Record<number, boolean>>>,
): ScrollBehavior {
    // Virtuoso 라이브러리 ref
    const virtuosoRef = useRef<VirtuosoHandle>(null)
    const scrollContainerRef = useRef<HTMLDivElement>(null)
    const disableAutoScrollRef = useRef(false)

    // 상태
    const [showScrollToBottom, setShowScrollToBottom] = useState(false)
    const [isAtBottom, setIsAtBottom] = useState(false)

    // 디바운스된 스크롤 (성능 최적화)
    const scrollToBottomSmooth = useMemo(
        () => debounce(() => {
            virtuosoRef.current?.scrollTo({
                top: Number.MAX_SAFE_INTEGER,
                behavior: "smooth",
            })
        }, 10, { immediate: true }),
        [],
    )

    // 즉시 스크롤
    const scrollToBottomAuto = useCallback(() => {
        virtuosoRef.current?.scrollTo({
            top: Number.MAX_SAFE_INTEGER,
            behavior: "auto",
        })
    }, [])

    // 특정 메시지로 스크롤
    const scrollToMessage = useCallback((messageIndex: number) => {
        const targetMessage = messages[messageIndex]
        if (!targetMessage) return

        // 그룹 인덱스 찾기
        const groupIndex = groupedMessages.findIndex(group =>
            Array.isArray(group)
                ? group.some(msg => msg.ts === targetMessage.ts)
                : group.ts === targetMessage.ts
        )

        if (groupIndex !== -1) {
            disableAutoScrollRef.current = true
            virtuosoRef.current?.scrollToIndex({
                index: groupIndex,
                align: "start",
                behavior: "smooth",
            })
        }
    }, [messages, groupedMessages])

    // 휠 이벤트 감지 (수동 스크롤 시 자동 스크롤 비활성화)
    useEvent("wheel", useCallback((event: WheelEvent) => {
        if (event.deltaY < 0) {  // 위로 스크롤
            disableAutoScrollRef.current = true
        }
    }, []), window, { passive: true })

    // 메시지 추가 시 자동 스크롤
    useEffect(() => {
        if (!disableAutoScrollRef.current) {
            scrollToBottomSmooth()
        }
    }, [groupedMessages.length, scrollToBottomSmooth])

    return {
        virtuosoRef, scrollContainerRef, disableAutoScrollRef,
        scrollToBottomSmooth, scrollToBottomAuto, scrollToMessage,
        toggleRowExpansion, handleRowHeightChange,
        showScrollToBottom, isAtBottom, scrolledPastUserMessage,
    }
}
```

### 훅 조합 사용 예시

```typescript
// ChatView.tsx
const ChatView = ({ isHidden, ... }: ChatViewProps) => {
    const { clineMessages: messages } = useExtensionState()

    // 채팅 상태 훅
    const chatState = useChatState(messages)
    const {
        inputValue, setInputValue,
        selectedImages, expandedRows, setExpandedRows,
        textAreaRef,
    } = chatState

    // 메시지 필터링 (useMemo)
    const visibleMessages = useMemo(
        () => filterVisibleMessages(messages),
        [messages]
    )
    const groupedMessages = useMemo(
        () => groupMessages(visibleMessages),
        [visibleMessages]
    )

    // 스크롤 동작 훅
    const scrollBehavior = useScrollBehavior(
        messages,
        visibleMessages,
        groupedMessages,
        expandedRows,
        setExpandedRows
    )

    // 메시지 핸들러 훅
    const messageHandlers = useMessageHandlers(/* ... */)

    return (
        <ChatLayout isHidden={isHidden}>
            <MessagesArea
                groupedMessages={groupedMessages}
                scrollBehavior={scrollBehavior}
                {...chatState}
            />
            <InputSection
                inputValue={inputValue}
                onInputChange={setInputValue}
                textAreaRef={textAreaRef}
            />
        </ChatLayout>
    )
}
```

### hdsp-agent 적용

```typescript
// frontend/hooks/useChatState.ts
import { useState, useMemo, useCallback, useRef } from "react"
import type { Message } from "../types"

export interface ChatState {
    inputValue: string
    setInputValue: (v: string) => void
    messages: Message[]
    isStreaming: boolean
    lastMessage: Message | undefined
    resetState: () => void
}

export function useChatState(initialMessages: Message[] = []): ChatState {
    const [inputValue, setInputValue] = useState("")
    const [messages, setMessages] = useState<Message[]>(initialMessages)
    const [isStreaming, setIsStreaming] = useState(false)

    const lastMessage = useMemo(() => messages.at(-1), [messages])

    const resetState = useCallback(() => {
        setInputValue("")
        setMessages([])
        setIsStreaming(false)
    }, [])

    return {
        inputValue, setInputValue,
        messages, isStreaming,
        lastMessage, resetState,
    }
}


// frontend/hooks/useScrollBehavior.ts
import { useRef, useCallback, useEffect } from "react"
import { debounce } from "lodash"

export function useScrollBehavior(messagesCount: number) {
    const containerRef = useRef<HTMLDivElement>(null)
    const autoScrollEnabled = useRef(true)

    const scrollToBottom = useCallback(
        debounce(() => {
            if (autoScrollEnabled.current) {
                containerRef.current?.scrollTo({
                    top: containerRef.current.scrollHeight,
                    behavior: "smooth"
                })
            }
        }, 50),
        []
    )

    // 메시지 추가 시 자동 스크롤
    useEffect(() => {
        scrollToBottom()
    }, [messagesCount, scrollToBottom])

    // 수동 스크롤 감지
    const handleScroll = useCallback((e: React.UIEvent) => {
        const target = e.target as HTMLDivElement
        const isNearBottom = target.scrollHeight - target.scrollTop - target.clientHeight < 100
        autoScrollEnabled.current = isNearBottom
    }, [])

    return { containerRef, handleScroll, scrollToBottom }
}
```

---

## 2. 컴포넌트 아키텍처

### 레이아웃 컴포넌트

```typescript
// components/layout/ChatLayout.tsx
interface ChatLayoutProps {
    isHidden: boolean
    children: React.ReactNode
}

export const ChatLayout: React.FC<ChatLayoutProps> = ({ isHidden, children }) => {
    return (
        <ChatLayoutContainer isHidden={isHidden}>
            <MainContent>{children}</MainContent>
        </ChatLayoutContainer>
    )
}

const ChatLayoutContainer = styled.div<{ isHidden: boolean }>`
    display: ${props => props.isHidden ? "none" : "grid"};
    grid-template-rows: 1fr auto;
    overflow: hidden;
    width: 100%;
    height: 100%;
    min-height: 100vh;
`

const MainContent = styled.div`
    display: flex;
    flex-direction: column;
    overflow: hidden;
`
```

### 컴포넌트 계층 구조

```
ChatView (Container)
├── Navbar
├── AutoApproveBar
├── ChatLayout (Layout)
│   ├── TaskSection
│   │   ├── TaskHeader
│   │   └── ContextWindow
│   ├── MessagesArea (Virtuoso)
│   │   ├── MessageRenderer
│   │   │   ├── ChatRow
│   │   │   ├── UserMessage
│   │   │   ├── BrowserSessionRow
│   │   │   └── ErrorRow
│   │   └── StickyUserMessage
│   └── InputSection
│       ├── ChatTextArea
│       ├── ActionButtons
│       └── SlashCommandMenu
└── WelcomeSection (조건부)
```

### 메시지 렌더러 패턴

```typescript
// components/messages/MessageRenderer.tsx
interface MessageRendererProps {
    message: ClineMessage | ClineMessage[]  // 단일 또는 그룹
    isExpanded: boolean
    onToggleExpand: () => void
    isLast: boolean
}

export const MessageRenderer: React.FC<MessageRendererProps> = ({
    message,
    isExpanded,
    onToggleExpand,
    isLast,
}) => {
    // 그룹 메시지 (브라우저 세션 등)
    if (Array.isArray(message)) {
        return (
            <BrowserSessionRow
                messages={message}
                isExpanded={isExpanded}
                onToggle={onToggleExpand}
            />
        )
    }

    // 단일 메시지 - 타입별 렌더링
    switch (message.say) {
        case "user_feedback":
            return <UserMessage message={message} />
        case "error":
            return <ErrorRow message={message} />
        case "api_req_started":
            return (
                <ChatRow
                    message={message}
                    isExpanded={isExpanded}
                    onToggle={onToggleExpand}
                    isLast={isLast}
                />
            )
        default:
            return <ChatRow message={message} isLast={isLast} />
    }
}
```

---

## 3. 가상화 (Virtualization)

### 개요
대량의 메시지를 효율적으로 렌더링하기 위해 `react-virtuoso` 라이브러리를 사용합니다.

### Virtuoso 설정

```typescript
// MessagesArea.tsx
import { Virtuoso, VirtuosoHandle } from "react-virtuoso"

interface MessagesAreaProps {
    groupedMessages: (ClineMessage | ClineMessage[])[]
    scrollBehavior: ScrollBehavior
}

export const MessagesArea: React.FC<MessagesAreaProps> = ({
    groupedMessages,
    scrollBehavior,
}) => {
    const { virtuosoRef, scrollContainerRef } = scrollBehavior

    return (
        <ScrollContainer ref={scrollContainerRef}>
            <Virtuoso
                ref={virtuosoRef}
                data={groupedMessages}
                itemContent={(index, message) => (
                    <MessageRenderer
                        message={message}
                        isLast={index === groupedMessages.length - 1}
                    />
                )}
                // 자동 스크롤 설정
                followOutput="smooth"
                // 아이템 크기 추정
                defaultItemHeight={80}
                // 오버스캔 (미리 렌더링할 아이템 수)
                overscan={200}
                // 스크롤 이벤트 핸들링
                atBottomStateChange={(atBottom) => {
                    scrollBehavior.setIsAtBottom(atBottom)
                }}
                rangeChanged={scrollBehavior.handleRangeChanged}
            />
        </ScrollContainer>
    )
}
```

### hdsp-agent 적용

```typescript
// JupyterLab에서는 @lumino/virtualdom 또는 react-window 사용 가능
import { FixedSizeList as List } from "react-window"

interface MessageListProps {
    messages: Message[]
}

export const MessageList: React.FC<MessageListProps> = ({ messages }) => {
    const listRef = useRef<List>(null)

    // 메시지 추가 시 스크롤
    useEffect(() => {
        listRef.current?.scrollToItem(messages.length - 1)
    }, [messages.length])

    return (
        <List
            ref={listRef}
            height={400}
            itemCount={messages.length}
            itemSize={60}  // 예상 높이
            width="100%"
        >
            {({ index, style }) => (
                <div style={style}>
                    <MessageRow message={messages[index]} />
                </div>
            )}
        </List>
    )
}
```

---

## 4. Context 기반 전역 상태

### ExtensionStateContext

```typescript
// context/ExtensionStateContext.tsx
export interface ExtensionStateContextType extends ExtensionState {
    didHydrateState: boolean
    showWelcome: boolean

    // 모델 목록
    openRouterModels: Record<string, ModelInfo>
    groqModels: Record<string, ModelInfo>

    // MCP 서버
    mcpServers: McpServer[]

    // 네비게이션 상태
    showMcp: boolean
    showSettings: boolean
    showHistory: boolean

    // Setter
    setShowAnnouncement: (value: boolean) => void
    setMcpServers: (value: McpServer[]) => void

    // 네비게이션 함수
    navigateToMcp: (tab?: McpViewTab) => void
    navigateToSettings: (targetSection?: string) => void
}

const ExtensionStateContext = createContext<ExtensionStateContextType | undefined>(undefined)

export function ExtensionStateProvider({ children }: { children: ReactNode }) {
    // gRPC 구독으로 상태 수신
    const [state, setState] = useState<ExtensionState>(defaultState)
    const [didHydrateState, setDidHydrateState] = useState(false)

    useEffect(() => {
        // 상태 구독
        const subscription = StateServiceClient.subscribeToState(
            EmptyRequest.create(),
            (newState) => {
                setState(convertProtoToState(newState))
                setDidHydrateState(true)
            }
        )
        return () => subscription.cancel()
    }, [])

    const value = useMemo(() => ({
        ...state,
        didHydrateState,
        // ... setters and navigation
    }), [state, didHydrateState])

    return (
        <ExtensionStateContext.Provider value={value}>
            {children}
        </ExtensionStateContext.Provider>
    )
}

export function useExtensionState() {
    const context = useContext(ExtensionStateContext)
    if (!context) {
        throw new Error("useExtensionState must be used within ExtensionStateProvider")
    }
    return context
}
```

### hdsp-agent 적용

```typescript
// frontend/context/AgentContext.tsx
import { createContext, useContext, useState, useEffect, useMemo } from "react"
import type { AgentState, Message, Config } from "../types"

interface AgentContextType {
    messages: Message[]
    config: Config
    isConnected: boolean
    isStreaming: boolean

    // 액션
    sendMessage: (content: string) => Promise<void>
    setConfig: (config: Partial<Config>) => void
    clearHistory: () => void
}

const AgentContext = createContext<AgentContextType | undefined>(undefined)

export function AgentProvider({ children }: { children: React.ReactNode }) {
    const [messages, setMessages] = useState<Message[]>([])
    const [config, setConfigState] = useState<Config>(defaultConfig)
    const [isConnected, setIsConnected] = useState(false)
    const [isStreaming, setIsStreaming] = useState(false)

    // SSE 연결
    useEffect(() => {
        const eventSource = new EventSource("/hdsp-agent/stream")

        eventSource.onopen = () => setIsConnected(true)
        eventSource.onerror = () => setIsConnected(false)

        eventSource.addEventListener("message", (event) => {
            const chunk = JSON.parse(event.data)
            // 메시지 업데이트
            setMessages(prev => updateMessages(prev, chunk))
        })

        return () => eventSource.close()
    }, [])

    const sendMessage = async (content: string) => {
        setIsStreaming(true)
        try {
            await fetch("/hdsp-agent/chat", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ content, config })
            })
        } finally {
            setIsStreaming(false)
        }
    }

    const value = useMemo(() => ({
        messages, config, isConnected, isStreaming,
        sendMessage,
        setConfig: (c: Partial<Config>) => setConfigState(p => ({ ...p, ...c })),
        clearHistory: () => setMessages([]),
    }), [messages, config, isConnected, isStreaming])

    return (
        <AgentContext.Provider value={value}>
            {children}
        </AgentContext.Provider>
    )
}

export function useAgent() {
    const context = useContext(AgentContext)
    if (!context) {
        throw new Error("useAgent must be used within AgentProvider")
    }
    return context
}
```

---

## 5. 접근성 (Accessibility)

### 스크린 리더 알림

```typescript
// hooks/useMenuAnnouncement.ts
interface UseMenuAnnouncementOptions<T> {
    items: T[]
    selectedIndex: number
    getItemLabel: (item: T) => string
    isItemSelectable?: (item: T) => boolean
}

export function useMenuAnnouncement<T>({
    items,
    selectedIndex,
    getItemLabel,
    isItemSelectable = () => true,
}: UseMenuAnnouncementOptions<T>) {
    const [announcement, setAnnouncement] = useState("")
    const hasNavigatedRef = useRef(false)
    const previousIndexRef = useRef(selectedIndex)

    useEffect(() => {
        // 인덱스 변경 감지 (초기 렌더링 제외)
        if (previousIndexRef.current !== selectedIndex) {
            hasNavigatedRef.current = true
        }
        previousIndexRef.current = selectedIndex

        if (!hasNavigatedRef.current) return

        if (items.length > 0 && selectedIndex >= 0) {
            const selectedItem = items[selectedIndex]
            if (isItemSelectable(selectedItem)) {
                const label = getItemLabel(selectedItem)
                // "항목명, 3 of 10" 형식
                setAnnouncement(`${label}, ${selectedIndex + 1} of ${items.length}`)

                // 1초 후 클리어 (DOM 쿼리 방해 방지)
                const timer = setTimeout(() => setAnnouncement(""), 1000)
                return () => clearTimeout(timer)
            }
        }
    }, [selectedIndex, items, getItemLabel, isItemSelectable])

    return { announcement }
}
```

### aria-live 리전 사용

```typescript
// components/SlashCommandMenu.tsx
const SlashCommandMenu: React.FC<Props> = ({ commands, selectedIndex, onSelect }) => {
    const { announcement } = useMenuAnnouncement({
        items: commands,
        selectedIndex,
        getItemLabel: (cmd) => `${cmd.name}: ${cmd.description}`,
    })

    return (
        <div role="listbox" aria-label="Slash commands">
            {/* 스크린 리더 전용 알림 영역 */}
            <div
                role="status"
                aria-live="polite"
                aria-atomic="true"
                className="sr-only"  // visually hidden
            >
                {announcement}
            </div>

            {commands.map((cmd, index) => (
                <div
                    key={cmd.name}
                    role="option"
                    aria-selected={index === selectedIndex}
                    tabIndex={index === selectedIndex ? 0 : -1}
                    onClick={() => onSelect(cmd)}
                >
                    <span>{cmd.name}</span>
                    <span>{cmd.description}</span>
                </div>
            ))}
        </div>
    )
}
```

### 키보드 네비게이션

```typescript
// 컴포넌트에서 키보드 핸들링
const handleKeyDown = useCallback((e: KeyboardEvent) => {
    switch (e.key) {
        case "ArrowUp":
            e.preventDefault()
            setSelectedIndex(prev => Math.max(0, prev - 1))
            break
        case "ArrowDown":
            e.preventDefault()
            setSelectedIndex(prev => Math.min(items.length - 1, prev + 1))
            break
        case "Enter":
            e.preventDefault()
            onSelect(items[selectedIndex])
            break
        case "Escape":
            e.preventDefault()
            onClose()
            break
    }
}, [items, selectedIndex, onSelect, onClose])

useEffect(() => {
    document.addEventListener("keydown", handleKeyDown)
    return () => document.removeEventListener("keydown", handleKeyDown)
}, [handleKeyDown])
```

---

## 6. 성능 최적화 패턴

### useMemo / useCallback 활용

```typescript
// 비용이 큰 계산 메모이제이션
const modifiedMessages = useMemo(() => {
    const sliced = messages.slice(1)
    const withHooks = hooksEnabled ? combineHookSequences(sliced) : sliced
    return combineErrorRetryMessages(
        combineApiRequests(
            combineCommandSequences(withHooks)
        )
    )
}, [messages, hooksEnabled])

// 메트릭 계산 메모이제이션
const apiMetrics = useMemo(
    () => getApiMetrics(modifiedMessages),
    [modifiedMessages]
)

// 핸들러 메모이제이션
const handleSubmit = useCallback(async () => {
    if (!inputValue.trim()) return
    await sendMessage(inputValue)
    setInputValue("")
}, [inputValue, sendMessage])
```

### 디바운스 입력

```typescript
// 입력 디바운스
const debouncedSearch = useMemo(
    () => debounce((query: string) => {
        searchCommands(query)
    }, 150),
    [searchCommands]
)

// 스크롤 디바운스
const scrollToBottomSmooth = useMemo(
    () => debounce(() => {
        virtuosoRef.current?.scrollTo({
            top: Number.MAX_SAFE_INTEGER,
            behavior: "smooth",
        })
    }, 10, { immediate: true }),
    [],
)
```

---

## 요약

| 패턴 | 핵심 이점 | hdsp-agent 적용 우선순위 |
|------|----------|--------------------------|
| 커스텀 훅 분리 | 관심사 분리, 재사용성 | 높음 |
| 레이아웃 컴포넌트 | 구조 일관성 | 중간 |
| Virtuoso 가상화 | 대량 메시지 성능 | 높음 |
| Context 전역 상태 | 상태 공유 | 높음 |
| 접근성 훅 | 스크린 리더 지원 | 낮음 |
| useMemo/useCallback | 렌더링 최적화 | 중간 |

### 즉시 적용 가능

1. **useChatState 패턴**: 채팅 상태 관리 훅 구조 그대로 사용
2. **useScrollBehavior 패턴**: 자동 스크롤 로직 포팅
3. **Context 구조**: SSE 기반 상태 구독으로 변환
