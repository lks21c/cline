# 통신 프로토콜

Cline 프로젝트의 Extension-Webview 간 통신 구조를 분석합니다.

---

## 1. Proto 기반 통신 개요

### 아키텍처

```
┌─────────────────┐       Message Passing       ┌──────────────────┐
│    Extension    │ ◄─────────────────────────► │     Webview      │
│   (Node.js)     │      gRPC-like Protocol     │    (React)       │
│                 │                             │                  │
│  ┌───────────┐  │      Proto Messages         │  ┌────────────┐  │
│  │ Handlers  │◄─┼────────────────────────────►│  │ProtoBusClient│ │
│  └───────────┘  │                             │  └────────────┘  │
└─────────────────┘                             └──────────────────┘
```

### 디렉토리 구조

```
proto/
├── cline/                    # 비즈니스 로직 프로토콜
│   ├── common.proto          # 공통 타입 (Empty, StringRequest 등)
│   ├── ui.proto              # UI 메시지 타입 (ClineMessage, Enums)
│   ├── task.proto            # 작업 관리 서비스
│   ├── state.proto           # 상태 동기화 서비스
│   ├── file.proto            # 파일 작업 서비스
│   ├── mcp.proto             # MCP 서버 통합
│   ├── account.proto         # 계정 관리
│   ├── models.proto          # 모델 관리
│   └── browser.proto         # 브라우저 자동화
└── host/                     # IDE 호스트 프로토콜
    ├── diff.proto            # 차이점 보기
    ├── window.proto          # 창 관리
    └── workspace.proto       # 워크스페이스 작업
```

---

## 2. Proto 메시지 정의

### 공통 타입 (common.proto)

```protobuf
syntax = "proto3";
package cline;

// 빈 요청/응답
message EmptyRequest {}
message Empty {}

// 단순 래퍼 타입
message StringRequest {
  string value = 2;
}

message StringArrayRequest {
  repeated string value = 2;
}

message Int64Request {
  int64 value = 2;
}

message BooleanRequest {
  bool value = 2;
}

// 진단 정보
message Diagnostic {
  string message = 1;
  DiagnosticRange range = 2;
  DiagnosticSeverity severity = 3;
  optional string source = 4;
}

enum DiagnosticSeverity {
  DIAGNOSTIC_ERROR = 0;
  DIAGNOSTIC_WARNING = 1;
  DIAGNOSTIC_INFORMATION = 2;
  DIAGNOSTIC_HINT = 3;
}
```

### 서비스 정의 (task.proto)

```protobuf
syntax = "proto3";
package cline;

import "cline/common.proto";
import "cline/state.proto";

service TaskService {
  // 단방향 RPC
  rpc cancelTask(EmptyRequest) returns (Empty);
  rpc clearTask(EmptyRequest) returns (Empty);

  // 요청-응답 RPC
  rpc newTask(NewTaskRequest) returns (String);
  rpc showTaskWithId(StringRequest) returns (TaskResponse);
  rpc getTaskHistory(GetTaskHistoryRequest) returns (TaskHistoryArray);

  // 피드백 RPC
  rpc askResponse(AskResponseRequest) returns (Empty);
  rpc taskFeedback(StringRequest) returns (Empty);
}

// 복잡한 요청 메시지
message NewTaskRequest {
  Metadata metadata = 1;
  string text = 2;
  repeated string images = 3;
  repeated string files = 4;
  optional Settings task_settings = 5;
}

// 응답 메시지
message TaskResponse {
  string id = 1;
  string task = 2;
  int64 ts = 3;
  bool is_favorited = 4;
  int64 size = 5;
  double total_cost = 6;
  int32 tokens_in = 7;
  int32 tokens_out = 8;
}
```

### UI 메시지 Enum (ui.proto)

```protobuf
// 메시지 유형
enum ClineMessageType {
  ASK = 0;   // 사용자 입력 요청
  SAY = 1;   // 정보 표시
}

// Ask 유형 (사용자 응답 필요)
enum ClineAsk {
  FOLLOWUP = 0;
  PLAN_MODE_RESPOND = 1;
  COMMAND = 2;
  TOOL = 5;
  API_REQ_FAILED = 6;
  RESUME_TASK = 7;
  BROWSER_ACTION_LAUNCH = 10;
  USE_MCP_SERVER = 11;
  NEW_TASK = 12;
}

// Say 유형 (정보 표시)
enum ClineSay {
  TASK = 0;
  ERROR = 1;
  API_REQ_STARTED = 2;
  API_REQ_FINISHED = 3;
  TEXT = 4;
  REASONING = 5;
  USER_FEEDBACK = 7;
  COMMAND_SAY = 10;
  BROWSER_ACTION = 15;
  MCP_SERVER_RESPONSE = 18;
  CHECKPOINT_CREATED = 24;
  GENERATE_EXPLANATION = 29;
}
```

---

## 3. ProtoBusClient 구현

### 클라이언트 기본 클래스

```typescript
// webview-ui/src/services/grpc-client-base.ts
import { v4 as uuidv4 } from "uuid"

export interface Callbacks<TResponse> {
    onResponse: (response: TResponse) => void
    onError: (error: Error) => void
    onComplete: () => void
}

export abstract class ProtoBusClient {
    static serviceName: string

    // 단방향 요청 (Unary)
    static async makeUnaryRequest<TRequest, TResponse>(
        methodName: string,
        request: TRequest,
        encodeRequest: (_: TRequest) => unknown,
        decodeResponse: (_: { [key: string]: any }) => TResponse,
    ): Promise<TResponse> {
        return new Promise((resolve, reject) => {
            const requestId = uuidv4()

            // 응답 리스너 등록
            const handleResponse = (event: MessageEvent) => {
                const message = event.data
                if (message.type === "grpc_response" &&
                    message.grpc_response?.request_id === requestId) {

                    window.removeEventListener("message", handleResponse)

                    if (message.grpc_response.message) {
                        const response = PLATFORM_CONFIG.decodeMessage(
                            message.grpc_response.message,
                            decodeResponse
                        )
                        resolve(response)
                    } else if (message.grpc_response.error) {
                        reject(new Error(message.grpc_response.error))
                    }
                }
            }

            window.addEventListener("message", handleResponse)

            // 요청 전송
            PLATFORM_CONFIG.postMessage({
                type: "grpc_request",
                grpc_request: {
                    service: this.serviceName,
                    method: methodName,
                    message: PLATFORM_CONFIG.encodeMessage(request, encodeRequest),
                    request_id: requestId,
                    is_streaming: false,
                },
            })
        })
    }

    // 스트리밍 요청
    static makeStreamingRequest<TRequest, TResponse>(
        methodName: string,
        request: TRequest,
        encodeRequest: (_: TRequest) => unknown,
        decodeResponse: (_: { [key: string]: any }) => TResponse,
        callbacks: Callbacks<TResponse>,
    ): () => void {
        const requestId = uuidv4()

        const handleResponse = (event: MessageEvent) => {
            const message = event.data
            if (message.type === "grpc_response" &&
                message.grpc_response?.request_id === requestId) {

                if (message.grpc_response.message) {
                    const response = PLATFORM_CONFIG.decodeMessage(
                        message.grpc_response.message,
                        decodeResponse
                    )
                    callbacks.onResponse(response)
                } else if (message.grpc_response.error) {
                    callbacks.onError(new Error(message.grpc_response.error))
                    window.removeEventListener("message", handleResponse)
                }

                // 스트림 종료 확인
                if (message.grpc_response.is_streaming === false) {
                    callbacks.onComplete()
                    window.removeEventListener("message", handleResponse)
                }
            }
        }

        window.addEventListener("message", handleResponse)

        PLATFORM_CONFIG.postMessage({
            type: "grpc_request",
            grpc_request: {
                service: this.serviceName,
                method: methodName,
                message: PLATFORM_CONFIG.encodeMessage(request, encodeRequest),
                request_id: requestId,
                is_streaming: true,
            },
        })

        // 취소 함수 반환
        return () => {
            window.removeEventListener("message", handleResponse)
            PLATFORM_CONFIG.postMessage({
                type: "grpc_request_cancel",
                grpc_request_cancel: { request_id: requestId },
            })
        }
    }
}
```

### 생성된 서비스 클라이언트

```typescript
// src/generated/nice-grpc/TaskServiceClient.ts (자동 생성)
export class TaskServiceClient extends ProtoBusClient {
    static serviceName = "cline.TaskService"

    static async cancelTask(request: EmptyRequest): Promise<Empty> {
        return this.makeUnaryRequest(
            "cancelTask",
            request,
            EmptyRequest.encode,
            Empty.decode
        )
    }

    static async newTask(request: NewTaskRequest): Promise<String> {
        return this.makeUnaryRequest(
            "newTask",
            request,
            NewTaskRequest.encode,
            String.decode
        )
    }

    static subscribeToState(
        request: EmptyRequest,
        callbacks: Callbacks<ExtensionState>
    ): () => void {
        return this.makeStreamingRequest(
            "subscribeToState",
            request,
            EmptyRequest.encode,
            ExtensionState.decode,
            callbacks
        )
    }
}
```

---

## 4. 사용 패턴

### Webview에서 Extension 호출

```typescript
// 단순 호출
import { TaskServiceClient } from "@/services/grpc-client"
import { EmptyRequest } from "@shared/proto/cline/common"

// 작업 취소
await TaskServiceClient.cancelTask(EmptyRequest.create())

// 새 작업 생성
import { NewTaskRequest } from "@shared/proto/cline/task"

const taskId = await TaskServiceClient.newTask(
    NewTaskRequest.create({
        text: "Help me refactor this code",
        images: [base64Image],
        files: ["/path/to/file.ts"],
    })
)
```

### 스트리밍 구독

```typescript
// Context에서 상태 구독
import { StateServiceClient } from "@/services/grpc-client"
import { EmptyRequest } from "@shared/proto/cline/common"

useEffect(() => {
    const cancel = StateServiceClient.subscribeToState(
        EmptyRequest.create(),
        {
            onResponse: (state) => {
                setState(convertProtoToState(state))
            },
            onError: (error) => {
                console.error("State subscription error:", error)
            },
            onComplete: () => {
                console.log("State subscription completed")
            },
        }
    )

    return () => cancel()  // 컴포넌트 언마운트 시 취소
}, [])
```

### 설정 업데이트

```typescript
import { UiServiceClient } from "@/services/grpc-client"
import { StringRequest } from "@shared/proto/cline/common"

// 설정 섹션으로 스크롤
await UiServiceClient.scrollToSettings(
    StringRequest.create({ value: "browser" })
)
```

---

## 5. Extension 측 핸들러

### 핸들러 구조

```typescript
// src/core/controller/task/newTask.ts
export async function newTask(
    controller: Controller,
    request: NewTaskRequest,
    responseStream: StreamingResponseHandler<String>,
    requestId?: string,
): Promise<void> {
    const { text, images, files, taskSettings } = request

    // 작업 생성 로직
    const taskId = await controller.createTask({
        text,
        images: images.map(decodeBase64),
        files,
        settings: taskSettings,
    })

    // 응답 전송
    await responseStream(String.create({ value: taskId }), false)
}
```

### 핸들러 등록

```typescript
// src/core/controller/handlers/index.ts
export const taskHandlers = {
    "cancelTask": cancelTask,
    "clearTask": clearTask,
    "newTask": newTask,
    "showTaskWithId": showTaskWithId,
    "getTaskHistory": getTaskHistory,
    "askResponse": askResponse,
}

// 라우터
export function handleGrpcRequest(
    service: string,
    method: string,
    request: any,
    responseStream: StreamingResponseHandler<any>,
    requestId: string,
) {
    const handlers = {
        "cline.TaskService": taskHandlers,
        "cline.UiService": uiHandlers,
        "cline.StateService": stateHandlers,
        // ...
    }

    const serviceHandlers = handlers[service]
    if (!serviceHandlers) {
        throw new Error(`Unknown service: ${service}`)
    }

    const handler = serviceHandlers[method]
    if (!handler) {
        throw new Error(`Unknown method: ${method}`)
    }

    return handler(controller, request, responseStream, requestId)
}
```

---

## 6. 메시지 형식

### 요청 메시지

```typescript
interface GrpcRequest {
    type: "grpc_request"
    grpc_request: {
        service: string        // "cline.TaskService"
        method: string         // "newTask"
        message: any           // Proto 인코딩된 메시지
        request_id: string     // UUID
        is_streaming: boolean  // 스트리밍 여부
    }
}
```

### 응답 메시지

```typescript
interface GrpcResponse {
    type: "grpc_response"
    grpc_response: {
        request_id: string     // 요청 ID와 매칭
        message?: any          // 성공 시 Proto 인코딩된 응답
        error?: string         // 실패 시 에러 메시지
        is_streaming: boolean  // false면 스트림 종료
    }
}
```

### 취소 메시지

```typescript
interface GrpcRequestCancel {
    type: "grpc_request_cancel"
    grpc_request_cancel: {
        request_id: string     // 취소할 요청 ID
    }
}
```

---

## 7. Proto 타입 생성

### 빌드 명령

```bash
npm run protos
```

### 생성되는 파일

```
src/
├── shared/proto/              # 공유 타입 정의
│   └── cline/
│       ├── common.ts
│       ├── ui.ts
│       ├── task.ts
│       └── state.ts
├── generated/
│   ├── grpc-js/               # gRPC-JS 서비스 구현
│   ├── nice-grpc/             # Promise 기반 클라이언트
│   └── hosts/                 # 호스트 핸들러
```

---

## 8. hdsp-agent 적용

### REST/SSE 기반 변환

Cline의 gRPC-like 프로토콜을 JupyterLab의 REST API + SSE로 변환합니다.

```python
# backend/api/routes.py
from fastapi import APIRouter, HTTPException
from fastapi.responses import StreamingResponse
from pydantic import BaseModel
from typing import List, Optional
import asyncio
import json

router = APIRouter(prefix="/hdsp-agent")

# Pydantic 모델 (Proto 메시지 대체)
class NewTaskRequest(BaseModel):
    text: str
    images: List[str] = []
    files: List[str] = []

class TaskResponse(BaseModel):
    id: str
    task: str
    ts: int
    total_cost: float
    tokens_in: int
    tokens_out: int

# 단방향 요청
@router.post("/task/new")
async def new_task(request: NewTaskRequest) -> dict:
    task_id = await task_service.create_task(
        text=request.text,
        images=request.images,
        files=request.files
    )
    return {"value": task_id}

@router.post("/task/cancel")
async def cancel_task():
    await task_service.cancel_current()
    return {}

@router.get("/task/{task_id}")
async def get_task(task_id: str) -> TaskResponse:
    task = await task_service.get_task(task_id)
    if not task:
        raise HTTPException(404, "Task not found")
    return TaskResponse(**task)
```

### SSE 스트리밍

```python
# backend/api/streaming.py
from fastapi import APIRouter
from fastapi.responses import StreamingResponse
from sse_starlette.sse import EventSourceResponse
import asyncio

router = APIRouter()

@router.get("/stream/state")
async def subscribe_to_state():
    """상태 변경 스트리밍 (SSE)"""
    async def event_generator():
        queue = asyncio.Queue()
        state_service.add_subscriber(queue)

        try:
            while True:
                state = await queue.get()
                yield {
                    "event": "state",
                    "data": json.dumps(state)
                }
        finally:
            state_service.remove_subscriber(queue)

    return EventSourceResponse(event_generator())


@router.get("/stream/messages")
async def subscribe_to_messages():
    """채팅 메시지 스트리밍"""
    async def event_generator():
        queue = asyncio.Queue()
        message_service.add_subscriber(queue)

        try:
            while True:
                message = await queue.get()
                yield {
                    "event": "message",
                    "data": json.dumps({
                        "type": message.type,  # "ask" | "say"
                        "say": message.say,    # ClineSay enum
                        "ask": message.ask,    # ClineAsk enum
                        "text": message.text,
                        "ts": message.ts,
                    })
                }
        finally:
            message_service.remove_subscriber(queue)

    return EventSourceResponse(event_generator())
```

### 프론트엔드 클라이언트

```typescript
// frontend/services/api-client.ts

// 타입 정의 (Proto 메시지 대체)
interface NewTaskRequest {
    text: string
    images?: string[]
    files?: string[]
}

interface TaskResponse {
    id: string
    task: string
    ts: number
    total_cost: number
    tokens_in: number
    tokens_out: number
}

class ApiClient {
    private baseUrl = "/hdsp-agent"

    // 단방향 요청
    async newTask(request: NewTaskRequest): Promise<string> {
        const response = await fetch(`${this.baseUrl}/task/new`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(request)
        })
        const data = await response.json()
        return data.value
    }

    async cancelTask(): Promise<void> {
        await fetch(`${this.baseUrl}/task/cancel`, { method: "POST" })
    }

    async getTask(taskId: string): Promise<TaskResponse> {
        const response = await fetch(`${this.baseUrl}/task/${taskId}`)
        return response.json()
    }

    // SSE 스트리밍 구독
    subscribeToState(callbacks: {
        onState: (state: ExtensionState) => void
        onError: (error: Error) => void
    }): () => void {
        const eventSource = new EventSource(`${this.baseUrl}/stream/state`)

        eventSource.addEventListener("state", (event) => {
            const state = JSON.parse(event.data)
            callbacks.onState(state)
        })

        eventSource.onerror = () => {
            callbacks.onError(new Error("SSE connection error"))
        }

        // 취소 함수 반환
        return () => eventSource.close()
    }

    subscribeToMessages(callbacks: {
        onMessage: (message: ClineMessage) => void
        onError: (error: Error) => void
    }): () => void {
        const eventSource = new EventSource(`${this.baseUrl}/stream/messages`)

        eventSource.addEventListener("message", (event) => {
            const message = JSON.parse(event.data)
            callbacks.onMessage(message)
        })

        eventSource.onerror = () => {
            callbacks.onError(new Error("SSE connection error"))
        }

        return () => eventSource.close()
    }
}

export const apiClient = new ApiClient()
```

### Context에서 사용

```typescript
// frontend/context/AgentContext.tsx
import { apiClient } from "../services/api-client"

export function AgentProvider({ children }: { children: React.ReactNode }) {
    const [state, setState] = useState<ExtensionState | null>(null)
    const [messages, setMessages] = useState<ClineMessage[]>([])

    useEffect(() => {
        // 상태 구독
        const cancelState = apiClient.subscribeToState({
            onState: setState,
            onError: console.error
        })

        // 메시지 구독
        const cancelMessages = apiClient.subscribeToMessages({
            onMessage: (msg) => setMessages(prev => [...prev, msg]),
            onError: console.error
        })

        return () => {
            cancelState()
            cancelMessages()
        }
    }, [])

    const sendTask = async (text: string, images?: string[]) => {
        const taskId = await apiClient.newTask({ text, images })
        console.log("Created task:", taskId)
    }

    return (
        <AgentContext.Provider value={{ state, messages, sendTask }}>
            {children}
        </AgentContext.Provider>
    )
}
```

---

## 요약

| Cline 패턴 | hdsp-agent 변환 | 비고 |
|-----------|----------------|------|
| Proto 메시지 | Pydantic 모델 | 타입 안전성 유지 |
| gRPC Unary | REST POST/GET | 동일한 요청-응답 |
| gRPC Streaming | SSE | 서버→클라이언트 푸시 |
| ProtoBusClient | ApiClient 클래스 | 동일 인터페이스 |
| request_id 추적 | EventSource 연결 ID | 연결 관리 |

### 핵심 변환 포인트

1. **Proto → Pydantic**: 메시지 정의를 Python 데이터클래스로 변환
2. **gRPC → REST**: RPC 메서드를 HTTP 엔드포인트로 매핑
3. **Streaming → SSE**: 서버 푸시를 Server-Sent Events로 구현
4. **Message Passing → Fetch API**: Webview 메시지를 HTTP 요청으로 변환
