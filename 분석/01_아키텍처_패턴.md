# 아키텍처 패턴

Cline 프로젝트에서 발견된 핵심 아키텍처 패턴을 분석합니다.

---

## 1. Host Abstraction Pattern

### 개요
IDE 독립적인 코어 로직을 위해 Host 추상화 레이어를 사용합니다. 이를 통해 VS Code 특화 코드를 분리하고, 동일한 비즈니스 로직을 다른 IDE (JupyterLab 등)에 재사용할 수 있습니다.

### 구현 구조

```
src/hosts/
├── HostProvider.ts          # 싱글톤 의존성 주입 컨테이너
├── vscode/                   # VS Code 특화 구현
│   ├── VscodeHostBridgeClient.ts
│   ├── VscodeWebviewCreator.ts
│   └── VscodeDiffViewCreator.ts
└── types.ts                  # 인터페이스 정의
```

### 핵심 코드 패턴

```typescript
// HostProvider.ts - 싱글톤 패턴
class HostProvider {
    private static instance: HostProvider;

    private webviewCreator: WebviewCreator;
    private diffViewCreator: DiffViewCreator;
    private terminalManager: TerminalManager;
    private hostBridgeProvider: HostBridgeProvider;

    static initialize(
        webviewCreator: WebviewCreator,
        diffViewCreator: DiffViewCreator,
        terminalManager: TerminalManager,
        hostBridgeProvider: HostBridgeProvider,
        // ...
    ) {
        if (HostProvider.instance) {
            throw new Error("HostProvider already initialized");
        }
        HostProvider.instance = new HostProvider(/* ... */);
    }

    static get(): HostProvider {
        if (!HostProvider.instance) {
            throw new Error("HostProvider not initialized");
        }
        return HostProvider.instance;
    }

    // 서비스 접근자
    createWebviewProvider(): WebviewProvider { /* ... */ }
    get window(): HostWindow { /* ... */ }
    get workspace(): HostWorkspace { /* ... */ }
}
```

### hdsp-agent 적용

```python
# backend/hosts/host_provider.py
class HostProvider:
    _instance = None

    @classmethod
    def initialize(cls, jupyter_app, notebook_tracker):
        if cls._instance is not None:
            raise RuntimeError("HostProvider already initialized")
        cls._instance = cls(jupyter_app, notebook_tracker)

    @classmethod
    def get(cls):
        if cls._instance is None:
            raise RuntimeError("HostProvider not initialized")
        return cls._instance

    def get_current_notebook(self):
        """현재 활성 노트북 반환"""
        pass

    def get_cell_content(self, cell_id):
        """셀 내용 조회"""
        pass
```

**장점**:
- 코어 로직과 IDE 특화 코드 분리
- 테스트 용이성 (Mock 주입)
- 다중 IDE 지원 가능

---

## 2. 계층적 상태 관리

### 개요
상태를 Global, Workspace, Task 세 레벨로 분리하여 관리합니다. 인메모리 캐시와 디바운스된 디스크 영속화를 조합하여 성능과 안정성을 모두 확보합니다.

### 구현 구조

```
src/core/webview/
├── StateManager.ts           # 상태 관리자
├── GlobalStateCache.ts       # 전역 상태
├── WorkspaceStateCache.ts    # 워크스페이스 상태
├── TaskStateCache.ts         # 작업별 상태
└── SecretsCache.ts           # 암호화된 민감 데이터
```

### 핵심 코드 패턴

```typescript
// StateManager.ts - 디바운스 영속화 패턴
class StateManager {
    private static instance: StateManager;
    private globalCache: Map<string, any> = new Map();
    private pendingWrites: Map<string, NodeJS.Timeout> = new Map();

    // 동기적 읽기 (인메모리)
    getGlobalState<T>(key: string): T | undefined {
        return this.globalCache.get(key);
    }

    // 즉시 캐시 업데이트 + 디바운스 디스크 저장
    async setGlobalState<T>(key: string, value: T): Promise<void> {
        // 1. 즉시 인메모리 업데이트
        this.globalCache.set(key, value);

        // 2. 기존 펜딩 쓰기 취소
        if (this.pendingWrites.has(key)) {
            clearTimeout(this.pendingWrites.get(key)!);
        }

        // 3. 500ms 디바운스 후 디스크 저장
        this.pendingWrites.set(key, setTimeout(async () => {
            await this.persistToDisk(key, value);
            this.pendingWrites.delete(key);
        }, 500));
    }
}
```

### 상태 계층 구조

| 레벨 | 용도 | 영속화 | 예시 |
|------|------|--------|------|
| Global | 확장 전역 설정 | VS Code globalState | API 키, 사용자 설정 |
| Workspace | 워크스페이스별 설정 | VS Code workspaceState | 프로젝트 설정 |
| Task | 작업별 상태 | taskHistory.json | 대화 기록, 실행 상태 |
| Secrets | 민감 데이터 | VS Code secrets | API 키 (암호화) |

### hdsp-agent 적용

```python
# backend/services/state_manager.py
import asyncio
from typing import Dict, Any, Optional

class StateManager:
    _instance = None
    DEBOUNCE_MS = 500

    def __init__(self):
        self._global_cache: Dict[str, Any] = {}
        self._pending_writes: Dict[str, asyncio.Task] = {}
        self._config_path = Path.home() / ".jupyter" / "hdsp_agent_state.json"

    def get_global_state(self, key: str) -> Optional[Any]:
        """동기적 인메모리 읽기"""
        return self._global_cache.get(key)

    async def set_global_state(self, key: str, value: Any):
        """디바운스된 상태 저장"""
        # 즉시 캐시 업데이트
        self._global_cache[key] = value

        # 기존 펜딩 취소
        if key in self._pending_writes:
            self._pending_writes[key].cancel()

        # 디바운스된 디스크 저장
        self._pending_writes[key] = asyncio.create_task(
            self._debounced_persist(key, value)
        )

    async def _debounced_persist(self, key: str, value: Any):
        await asyncio.sleep(self.DEBOUNCE_MS / 1000)
        await self._persist_to_disk()
```

---

## 3. 모듈식 핸들러 패턴

### 개요
각 기능을 독립적인 핸들러 함수로 분리합니다. 핸들러는 순수 함수로 구현되어 테스트와 유지보수가 용이합니다.

### 구현 구조

```
src/core/controller/
├── ui/                       # UI 이벤트 핸들러
│   ├── subscribeToState.ts
│   ├── subscribeToPartialMessage.ts
│   ├── scrollToSettings.ts
│   └── ...
├── task/                     # 작업 관련 핸들러
│   ├── newTask.ts
│   ├── cancelTask.ts
│   └── ...
├── file/                     # 파일 작업 핸들러
├── mcp/                      # MCP 통합 핸들러
└── models/                   # 모델 관리 핸들러
```

### 핵심 코드 패턴

```typescript
// 핸들러 시그니처 - Proto RPC와 1:1 매핑
export async function subscribeToPartialMessage(
    controller: Controller,                    // 의존성 주입
    request: EmptyRequest,                     // 요청 타입
    responseStream: StreamingResponseHandler<ClineMessage>,  // 스트림 응답
    requestId?: string,                        // 요청 추적 ID
): Promise<void> {
    // 구독 등록
    activeSubscriptions.add(responseStream);

    // 정리 핸들러
    const cleanup = () => {
        activeSubscriptions.delete(responseStream);
    };

    // 취소 시 정리
    if (requestId) {
        controller.registerCleanup(requestId, cleanup);
    }
}

// 이벤트 브로드캐스트
export async function sendPartialMessageEvent(
    partialMessage: ClineMessage
): Promise<void> {
    const promises = Array.from(activeSubscriptions).map(
        async (responseStream) => {
            try {
                await responseStream(partialMessage, false);
            } catch (error) {
                // 실패한 구독 제거
                activeSubscriptions.delete(responseStream);
            }
        }
    );
    await Promise.all(promises);
}
```

### 핸들러 등록 패턴

```typescript
// handlers/__init__.ts
export const handlers = {
    // UI 핸들러
    'subscribeToState': subscribeToState,
    'subscribeToPartialMessage': subscribeToPartialMessage,
    'scrollToSettings': scrollToSettings,

    // Task 핸들러
    'newTask': newTask,
    'cancelTask': cancelTask,

    // File 핸들러
    'readFile': readFile,
    'writeFile': writeFile,
};

// 라우터
export function handleRequest(
    methodName: string,
    controller: Controller,
    request: any,
    responseStream?: StreamingResponseHandler<any>
): Promise<any> {
    const handler = handlers[methodName];
    if (!handler) {
        throw new Error(`Unknown method: ${methodName}`);
    }
    return handler(controller, request, responseStream);
}
```

### hdsp-agent 적용

```python
# backend/handlers/__init__.py
from .chat import chat_handler, chat_stream_handler
from .cell_action import cell_action_handler
from .config import config_get_handler, config_save_handler

HANDLERS = {
    'chat.message': chat_handler,
    'chat.stream': chat_stream_handler,
    'cell.action': cell_action_handler,
    'config.get': config_get_handler,
    'config.save': config_save_handler,
}

def setup_handlers(web_app):
    """모든 핸들러 등록"""
    base_url = web_app.settings["base_url"]

    for path, handler in HANDLERS.items():
        full_path = url_path_join(base_url, "hdsp-agent", path.replace('.', '/'))
        web_app.add_handlers(".*$", [(full_path, handler)])
```

---

## 4. 초기화 순서 관리

### 개요
확장의 초기화 순서를 명확히 정의하여 의존성 문제를 방지합니다.

### 초기화 순서

```typescript
async function initialize(context: ExtensionContext): Promise<void> {
    // 1. 상태 관리자 초기화 (가장 먼저)
    await StateManager.initialize(context);

    // 2. 텔레메트리 설정
    await initializeDistinctId();
    PostHogClientProvider.getInstance();

    // 3. 에러 서비스 초기화
    ErrorService.initialize();

    // 4. 상태 마이그레이션 실행
    await runMigrations();

    // 5. Host Provider 초기화
    HostProvider.initialize(/* ... */);

    // 6. WebView 생성
    const webviewProvider = HostProvider.get().createWebviewProvider();

    // 7. 추가 서비스 초기화
    BannerService.initialize(controller);

    // 8. 준비 완료 이벤트 발행
    context.subscriptions.push(webviewProvider);
}
```

### hdsp-agent 적용

```python
# backend/__init__.py
def _load_jupyter_server_extension(server_app):
    """확장 초기화 순서"""

    # 1. 상태 관리자 초기화
    StateManager.initialize()

    # 2. 설정 로드
    ConfigManager.initialize()

    # 3. LLM 서비스 초기화
    LLMService.initialize(ConfigManager.get_instance())

    # 4. Host Provider 초기화
    HostProvider.initialize(server_app)

    # 5. 핸들러 등록
    setup_handlers(server_app.web_app)

    # 6. 로그 기록
    logger.info("HDSP Agent extension loaded")
```

---

## 5. 에러 처리 패턴

### 개요
계층화된 에러 처리와 사용자 피드백을 제공합니다.

### 에러 처리 흐름

```typescript
// 에러 서비스
class ErrorService {
    static async handle(error: Error, context: string): Promise<void> {
        // 1. 로깅
        logger.error(`[${context}]`, error);

        // 2. 텔레메트리 전송
        PostHogClient.captureException(error, { context });

        // 3. 사용자 알림 (심각도에 따라)
        if (error instanceof UserFacingError) {
            await HostProvider.get().window.showErrorMessage(error.message);
        }

        // 4. 복구 시도 (가능한 경우)
        if (error instanceof RecoverableError) {
            await this.attemptRecovery(error);
        }
    }
}
```

### hdsp-agent 적용

```python
# backend/services/error_service.py
class ErrorService:
    @staticmethod
    async def handle(error: Exception, context: str):
        # 1. 로깅
        logger.error(f"[{context}] {error}", exc_info=True)

        # 2. 사용자 응답 생성
        if isinstance(error, LLMConnectionError):
            return {
                "success": False,
                "error": {
                    "type": "LLM_CONNECTION_ERROR",
                    "message": "LLM 연결에 실패했습니다",
                    "retryable": True
                }
            }

        # 3. 기본 에러 응답
        return {
            "success": False,
            "error": {
                "type": "INTERNAL_ERROR",
                "message": str(error),
                "retryable": False
            }
        }
```

---

## 요약

| 패턴 | 핵심 이점 | hdsp-agent 적용 우선순위 |
|------|----------|------------------------|
| Host Abstraction | IDE 독립성, 테스트 용이 | 높음 |
| 계층적 상태 관리 | 성능 + 안정성 | 높음 |
| 모듈식 핸들러 | 유지보수성, 확장성 | 중간 |
| 초기화 순서 관리 | 안정적 시작 | 중간 |
| 에러 처리 | 사용자 경험 | 낮음 (기존 구현 활용) |
